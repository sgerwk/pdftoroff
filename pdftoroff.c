/*
 * pdftoroff
 *
 * convert a pdf into various text formats, trying to undo page, column and
 * paragraph formatting while retaining italic and bold face
 *
 * the output format can be:
 *	-r	roff
 *	-w	html
 *	-p	plain TeX
 *	-f	text with \[fontname] for font changes and \\ for backslashes
 *	-t	text
 *	-s fmt	arbitrary struct format as fmt
 *		for example, html can also be generated by:
 *	-m met	method for converting: 0-3
 *	-d dis	minimal distance between blocks of text in the page

./pdftoroff -s '
<p>,</p>
,,,,,,<i>,</i>,<b>,</b>,true,\,.,&lt;,&gt;,&amp;' file.pdf

 *
 * todo: see man page, section BUGS
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <poppler.h>
#include "pdfrects.h"

/*
 * parameters for the input (D=delta, %=percentage of page)
 */
struct measure {
	int newline;		/* more Dy than this is a newline */
	int newpar;		/* more Dy than this is a new paragraph */
	int rightreturn;	/* line end before this x% is a new paragraph */
	int newcolumnx;		/* more than this Dx% is new column (and) */
	int newcolumny;		/* more than this -Dy% is new column (and) */
	int indenttolerance;	/* tolerance for x at start of line */
	int headfooter;		/* ignore x,y of chars at begin/end of page */
	int textdistance;	/* distance between blocks of text */
};

/*
 * output strings
 */
struct format {
	char *parstart;		/* paragraph start */
	char *parend;		/* paragraph end */

	char *fontname;		/* format for printing font names, or NULL */

	char *plain;		/* set font face */
	char *italic;
	char *bold;
	char *bolditalic;

	char *italicbegin;	/* begin/end font face */
	char *italicend;
	char *boldbegin;
	char *boldend;

	gboolean reset;		/* reset and restart face at par breaks */

	char *backslash;
	char *firstdot;		/* substitute this for dot at start of line */
	char *less;
	char *greater;
	char *and;
};

/*
 * print reason for a paragraph break
 */
gboolean debugpar = FALSE;
void dnewpar(char *why) {
	if (debugpar)
		printf(why);
}

/*
 * start or end a font face
 *	start	TRUE to start the new face, FALSE to end the previous
 *	reset	TRUE to temporarily end or restore all active faces
 */
void face(gboolean start, gboolean reset, gboolean *italic, gboolean *bold,
		PopplerTextAttributes *attr, struct format *format) {
	gboolean newitalic, newbold;

	if (reset && ! format->reset)
		return;

	newitalic = NULL != strstr(attr->font_name, "Italic");
	newbold = NULL != strstr(attr->font_name, "Bold");

				/* font name */

	if (start && ! reset && *format->fontname != '\0')
		printf(format->fontname, attr->font_name);
			
				/* font start, no end except for resets */

	if (start) {
		if (! newitalic && ! newbold)
			printf(format->plain);
		else if (newitalic && ! newbold)
			printf(format->italic);
		else if (! newitalic && newbold)
			printf(format->bold);
		if (newitalic && newbold)
			printf(format->bolditalic);
	}
	if (! start && reset)
		printf(format->plain);

				/* font start-end */

	if (! start) {
		if (*bold && newbold == reset)
			printf(format->boldend);
		if (*italic && newitalic == reset)
			printf(format->italicend);
	}
	else {
		if (*italic == reset && newitalic)
			printf(format->italicbegin);
		if (*bold == reset && newbold)
			printf(format->boldbegin);
	}

				/* update current font */

	if (start && ! reset) {
		*italic = newitalic;
		*bold = newbold;
	}
}

/*
 * show a single character
 */
void showcharacter(char *cur, char *next, gboolean newpar,
		struct format *format) {
	if (*cur == '\\')
		printf(format->backslash);
	else if (newpar && *cur == '.')
		printf(format->firstdot);
	else if (*cur == '<')
		printf(format->less);
	else if (*cur == '>')
		printf(format->greater);
	else if (*cur == '&')
		printf(format->and);
	else if (*cur != '-' || (*next && *next != '\n'))
		fwrite(cur, 1, next - cur, stdout);
}

#ifdef _PDFRECTS_H

/*
 * show the characters in a box
 */
void showbox(PopplerPage *page, PopplerRectangle *zone,
		int method, struct measure *measure, struct format *format,
		gboolean *newpar, char **prev) {
	char *text, *cur, *next;
	int count;
	gdouble left, y;

	GList *attrlist, *attrelem;
	RectangleList *textarea;
	int ti = -1;
	PopplerRectangle *tr;
	PopplerTextAttributes *attr;
	gboolean detectcolumn;
	gboolean startcolumn, newline, italic, bold, hyphen, newface;

	PopplerRectangle *rects, crect;
	guint nrects, r;

				/* page content */

	text = poppler_page_get_text(page);
	attrlist = poppler_page_get_text_attributes(page);
	if (! text || ! attrlist)
		return;		/* no text in page */
	if (! poppler_page_get_text_layout(page, &rects, &nrects))
		return;		/* no text in page */

				/* text area to print */

	switch (method) {
	case 0:
		tr = poppler_rectangle_new();
		poppler_page_get_crop_box(page, tr);
		textarea = rectanglelist_new(1);
		rectanglelist_add(textarea, tr);
		detectcolumn = TRUE;
		break;
	case 1:
		tr = rectanglelist_boundingbox(page);
		textarea = rectanglelist_new(1);
		rectanglelist_add(textarea, tr);
		detectcolumn = FALSE;
		break;
	case 2:
		textarea = rectanglelist_textarea_distance(page,
				measure->textdistance);
		detectcolumn = FALSE;
		break;
	case 3:
		textarea = rectanglelist_new(1);
		rectanglelist_add(textarea, zone);
		detectcolumn = FALSE;
		break;
	default:
		printf("no such conversion method: %d\n", method);
		exit(EXIT_FAILURE);
	}

				/* cycle over (utf-8) characters in page */

	startcolumn = TRUE;
	italic = FALSE;
	bold = FALSE;
	hyphen = FALSE;
	newface = TRUE;

	attrelem = attrlist;
	attr = (PopplerTextAttributes *) (attrelem->data);

	for (cur = text, count = 0; *cur; cur = next, count++) {
		crect = rects[count];
		next = g_utf8_next_char(cur);
		if (zone != NULL && ! rectangle_contain(zone, &crect))
			continue;

					/* text rectangle this char is in */

		if (ti != -1 && rectangle_contain(tr, &crect))
			newline = FALSE;
		else {
			ti = rectanglelist_contain(textarea, &crect);
			if (ti != -1)
				tr = &textarea->rect[ti];
			else if (*cur == ' ') {
				ti = -1;
				tr = &crect;
			}
			else {
				printf("\n");
				printf("error: cannot find text rectangle\n");
				printf("character: %c ", *cur);
				printf("(%d)\n", *cur);
				printf("rectangle:\n");
				rectangle_print(&crect);
				printf("text area:\n");
				rectanglelist_print(textarea);
				exit(EXIT_FAILURE);
			}
			left = tr->x1;
			y = tr->y1 - measure->newline - 1;
			newline = TRUE;
		}

					/* explicit end of line */

		if (newline || *cur == '\n') {
			if (crect.x2 - left <
			    (tr->x2 - left) * measure->rightreturn / 100) {
				dnewpar("[1]");
				*newpar = TRUE;
			}
			else if (! hyphen)
				*prev = " ";
		}

					/* real character */

		if (*cur != '\n') {

					/* new column */

			if (detectcolumn &&
			    crect.x1 - left >
				(tr->x2 - tr->x1) * measure->newcolumnx / 100
				&&
			    y - crect.y1 >
				(tr->y2 - tr->y1) * measure->newcolumny / 100)
				startcolumn = TRUE;

			if (detectcolumn && startcolumn) {
				left = 10000;
				y = 10000;
				for (r = MAX(measure->headfooter, count);
				     r + measure->headfooter < nrects;
				     r++) {
					left = MIN(left, rects[r].x1);
					y = MIN(y, rects[r].y1);
				}
				if (left == 10000)
					y = 0; /* few chars, force newpar */
				y -= measure->newline + 1;
				startcolumn = FALSE;
			}

					/* y increase */

			if (crect.y1 - y > measure->newline) {
				if (crect.y1 - y > measure->newpar) {
					dnewpar("[2]");
					*newpar = TRUE;
				}
				y = crect.y1;
				if (crect.x1 - left >
						measure->indenttolerance) {
					dnewpar("[3]");
					*newpar = TRUE;
				}
			}

					/* new paragraph */

			if (*newpar) {
				face(FALSE, TRUE, &italic, &bold, attr, format);
				if (! ! strcmp(*prev, "start"))
					printf(format->parend);
				printf(format->parstart);
				face(TRUE, TRUE, &italic, &bold, attr, format);
			}
			else
				printf(*prev);
			*prev = "";

					/* start a new font face */

			if (newface && *cur != ' ') {
				face(TRUE, FALSE, &italic, &bold, attr, format);
				newface = FALSE;
			}

					/* print character */

			showcharacter(cur, next, *newpar, format);

					/* status of hyphen and newpar */

			hyphen = *cur == '-';
			*newpar = FALSE;
		}

				/* end of text with current font; read next */

		if (count == attr->end_index -
			     (g_unichar_isspace(*next) ? 1 : 0)) {
			attrelem = g_list_next(attrelem);
			if (! attrelem) {
				face(FALSE, TRUE, &italic, &bold, attr, format);
				break;
			}
			attr = (PopplerTextAttributes *) (attrelem->data);
			face(FALSE, FALSE, &italic, &bold, attr, format);
			newface = TRUE;
		}
	}

			/* end of page is like a carriage return in text */

	if (crect.x2 - left < (tr->x2 - left) * measure->rightreturn / 100) {
		dnewpar("[4]");
		*newpar = TRUE;
	}
	else if (! hyphen)
		*prev = " ";

	poppler_page_free_text_attributes(attrlist);
	g_free(rects);
	free(text);
}

void showpage(PopplerPage *page,
		int method, struct measure *measure, struct format *format,
		gboolean *newpar, char **prev) {
	RectangleList *textarea;
	gint r;

	if (method != 3) {
		showbox(page, NULL, method, measure, format, newpar, prev);
		return;
	}

	textarea =
		rectanglelist_textarea_distance(page, measure->textdistance);
	rectanglelist_sort(textarea);
	for (r = 0; r < textarea->num; r++)
		showbox(page, &textarea->rect[r], 3,
			measure, format, newpar, prev);
}

#else

/*
 * show a page, no-pdfrects version
 */
void showpage(PopplerPage *page,
		int method, struct measure *measure, struct format *format,
		gboolean *newpar, char **prev) {
	char *text, *cur, *next;
	int count;
	gdouble x = 0, y = 0;

	PopplerRectangle crop;
	gdouble width, height;
	GList *attrlist, *attrelem;
	PopplerTextAttributes *attr;
	gboolean startcolumn, italic, bold, hyphen, newface;

	PopplerRectangle *rects, crect;
	guint nrects, r;

				/* method */

	if (method != 0) {
		printf("only supported method in this version is 0\n");
		exit(EXIT_FAILURE);
	}

				/* page content */

	text = poppler_page_get_text(page);
	attrlist = poppler_page_get_text_attributes(page);
	if (! text || ! attrlist)
		return;		/* no text in page */
	if (! poppler_page_get_text_layout(page, &rects, &nrects))
		return;		/* no text in page */
	if (0)
		poppler_page_get_size(page, &width, &height);
	else {
		poppler_page_get_crop_box(page, &crop);
		width = crop.x2 - crop.x1;
		height = crop.y2 - crop.y1;
	}

	attrelem = attrlist;
	attr = (PopplerTextAttributes *) (attrelem->data);

				/* cycle over (utf-8) characters in page */

	startcolumn = TRUE;
	italic = FALSE;
	bold = FALSE;
	hyphen = FALSE;
	newface = TRUE;

	for (cur = text, count = 0; *cur; cur = next, count++) {
		crect = rects[count];
		next = g_utf8_next_char(cur);

					/* carriage return in text */

		if (*cur == '\n') {
			if (crect.x2 < width * measure->rightreturn / 100) {
				dnewpar("[1]");
				*newpar = TRUE;
			}
			else if (! hyphen)
				*prev = " ";
		}
		else {

					/* new column */

			if (crect.x1 - x > width * measure->newcolumnx / 100 &&
			    y - crect.y1 > height * measure->newcolumny / 100)
				startcolumn = TRUE;
			
			if (startcolumn) {
				x = 10000;
				y = 10000;
				for (r = MAX(measure->headfooter, count);
				     r + measure->headfooter < nrects;
				     r++) {
					x = MIN(x, rects[r].x1);
					y = MIN(y, rects[r].y1);
				}
				if (x == 10000)
					y = 0; /* few chars, force newpar */
				y -= measure->newline + 1;
				startcolumn = FALSE;
			}

					/* new paragraph */

			if (crect.y1 - y > measure->newline) {
				if (crect.y1 - y > measure->newpar) {
					dnewpar("[2]");
					*newpar = TRUE;
				}
				y = crect.y1;
				if (x < crect.x1 - measure->indenttolerance) {
					dnewpar("[3]");
					*newpar = TRUE;
				}
			}

			if (*newpar) {
				face(FALSE, TRUE, &italic, &bold, attr, format);
				if (! ! strcmp(*prev, "start"))
					printf(format->parend);
				printf(format->parstart);
				face(TRUE, TRUE, &italic, &bold, attr, format);
			}
			else
				printf(*prev);
			*prev = "";

					/* start a new font face */

			if (newface && *cur != ' ') {
				face(TRUE, FALSE, &italic, &bold, attr, format);
				newface = FALSE;
			}

					/* print character */

			showcharacter(cur, next, *newpar, format);

					/* status of hyphen and newpar */

			hyphen = *cur == '-';
			*newpar = FALSE;
		}
		
				/* end of text with current font; read next */

		if (count == attr->end_index -
			     (g_unichar_isspace(*next) ? 1 : 0)) {
			attrelem = g_list_next(attrelem);
			if (! attrelem) {
				face(FALSE, TRUE, &italic, &bold, attr, format);
				break;
			}
			attr = (PopplerTextAttributes *) (attrelem->data);
			face(FALSE, FALSE, &italic, &bold, attr, format);
			newface = TRUE;
		}
	}

			/* end of page is like a carriage return in text */

	if (crect.x2 < width * measure->rightreturn / 100) {
		dnewpar("[4]");
		*newpar = TRUE;
	}
	else if (! hyphen)
		*prev = " ";

	poppler_page_free_text_attributes(attrlist);
	g_free(rects);
	free(text);
}

/*
 * from file name to uri
 */
char *filenametouri(char *filename) {
	char *dir, *sep, *uri;

	if (filename[0] == '/') {
		dir = "";
		sep = "";
	}
	else {
		dir = malloc(4096);
		if (dir == NULL) {
			printf("failed to allocate memory for directory\n");
			exit(EXIT_FAILURE);
		}
		if (getcwd(dir, 4096) == NULL) {
			printf("error in obtaining the current directory\n");
			exit(EXIT_FAILURE);
		}
		sep = "/";
	}

	uri = malloc(strlen("file:") + strlen(dir) +
		strlen(sep) + strlen(filename) + 1);
	if (uri == NULL) {
		printf("failed to allocate memory for file name\n");
		exit(EXIT_FAILURE);
	}
	strcpy(uri, "file:");
	strcat(uri, dir);
	strcat(uri, sep);
	strcat(uri, filename);

	return uri;
}

#endif

/*
 * parse a string into a struct format
 */
struct format *parseformat(char *s) {
	struct format *f;
	char *c, *t;

	c = strdup(s);
	f = malloc(sizeof(struct format));
	memset(f, 0, sizeof(struct format));

	if (! (f->parstart = strsep(&c, ",")))
		return NULL;
	if (! (f->parend = strsep(&c, ",")))
		return NULL;
	if (! (f->fontname = strsep(&c, ",")))
		return NULL;
	if (! (f->plain = strsep(&c, ",")))
		return NULL;
	if (! (f->italic = strsep(&c, ",")))
		return NULL;
	if (! (f->bold = strsep(&c, ",")))
		return NULL;
	if (! (f->bolditalic = strsep(&c, ",")))
		return NULL;
	if (! (f->italicbegin = strsep(&c, ",")))
		return NULL;
	if (! (f->italicend = strsep(&c, ",")))
		return NULL;
	if (! (f->boldbegin = strsep(&c, ",")))
		return NULL;
	if (! (f->boldend = strsep(&c, ",")))
		return NULL;
	if (! (t = strsep(&c, ",")))
		return NULL;
	f->reset = ! strcmp(t, "true");
	if (! (f->backslash = strsep(&c, ",")))
		return NULL;
	if (! (f->firstdot = strsep(&c, ",")))
		return NULL;
	if (! (f->less = strsep(&c, ",")))
		return NULL;
	if (! (f->greater = strsep(&c, ",")))
		return NULL;
	if (! (f->and = strsep(&c, ",")))
		return NULL;

	return f;
}

/*
 * main
 */
int main(int argc, char *argv[]) {
	gboolean usage, opterr;
	gboolean method = 1;
	char *filename;
	PopplerDocument *doc;
	int npage;
	PopplerPage *page;
	gboolean newpar = TRUE;
	char *prev = "start";
	struct measure measure = {8, 25, 80, 30, 40, 4, 20, 25};
	struct format *format;
	struct format roff = {
		".ti 1\n", "\n",
		"",
		"\\fR", "\\fI", "\\fB", "\\f[BI]",
		"", "", "", "",
		FALSE,
		"\\", "\\[char46]", "<", ">", "&"
	};
	struct format html = {
		"\n<p>", "</p>\n",
		"",
		"", "", "", "",
		"<i>", "</i>", "<b>", "</b>",
		TRUE,
		"\\", ".", "&lt;", "&gt;", "&amp;"
	};
	struct format tex = {
		"", "\n\n",
		"",
		"\\rm ", "\\it ", "\\bf ", "\\bf ", /* FIXME: bold+italic */
		"", "", "", "",
		FALSE,
		"\\backslash ", ".", "<", ">", "\\& "
	};
	struct format textfont = {
		"", "\n",
		"\\[%s]",
		"", "", "", "",
		"", "", "", "",
		FALSE,
		"\\\\", ".", "<", ">", "&"
	};
	struct format text = {
		"", "\n",
		"",
		"", "", "", "",
		"", "", "", "",
		FALSE,
		"\\", ".", "<", ">", "&"
	};

				/* arguments */

	format = &roff;
	usage = FALSE;
	opterr = FALSE;
	while (argc > 1 && argv[1][0] == '-') {
		switch(argv[1][1]) {
		case 'r':
			format = &roff;
			break;
		case 'w':
			format = &html;
			break;
		case 'p':
			format = &tex;
			break;
		case 'f':
			format = &textfont;
			break;
		case 't':
			format = &text;
			break;
		case 's':
			if (argc - 1 < 2) {
				printf("-s requires a format\n");
				usage = TRUE;
				opterr = TRUE;
				break;
			}
			format = parseformat(argv[2]);
			if (format == NULL) {
				printf("invalid format: %s\n", argv[2]);
				usage = TRUE;
				opterr = TRUE;
				break;
			}
			argc--;
			argv++;
			break;
		case 'm':
			if (argc - 1 < 2) {
				printf("-m requires a format (0-3)\n");
				usage = TRUE;
				opterr = TRUE;
				break;
			}
			method = atoi(argv[2]);
			argc--;
			argv++;
			break;
		case 'd':
			if (argc - 1 < 2) {
				printf("-d requires a distance\n");
				usage = TRUE;
				opterr = TRUE;
				break;
			}
			measure.textdistance = atoi(argv[2]);
			argc--;
			argv++;
			break;
		case 'v':
			debugpar = TRUE;
			break;
		case 'h':
			usage = TRUE;
			opterr = FALSE;
			break;
		default:
			printf("option not recognized: %s\n", argv[1]);
			usage = TRUE;
			opterr = TRUE;
			break;
		}
		argc--;
		argv++;
	}
	if (argc - 1 < 1 || usage) {
		printf("pdftoroff converts pdf to various text formats\n");
		printf("usage:\n\tpdftoroff [-r|-w|-p|-f|-t|-s fmt]");
		printf(" [-m method [-d dist]] [-v] file.pdf\n");
		printf("\t\t-r\t\tconvert to roff (default)\n");
		printf("\t\t-w\t\tconvert to html\n");
		printf("\t\t-p\t\tconvert to plain TeX\n");
		printf("\t\t-f\t\tconvert to text with font changes\n");
		printf("\t\t-t\t\tconvert to text\n");
		printf("\t\t-s fmt\t\toutput format strings\n");
		printf("\t\t-m method\tconversion method (0-3)\n");
		printf("\t\t-d distance\tminimal distance between ");
		printf("blocks of text\n");
		printf("\t\t-v\t\treason for line breaks\n");

		exit(opterr || ! usage ? EXIT_FAILURE : EXIT_SUCCESS);
	}

	filename = filenametouri(argv[1]);

				/* open document and scan pages */

	doc = poppler_document_new_from_file(filename, NULL, NULL);
	if (doc == NULL) {
		printf("error opening file %s\n", filename);
		exit(EXIT_FAILURE);
	}

	for (npage = 0; npage < poppler_document_get_n_pages(doc); npage++) {
		page = poppler_document_get_page(doc, npage);
		showpage(page, method, &measure, format, &newpar, &prev);
	}
	if (! ! strcmp(prev, "start"))
		printf(format->parend);

	free(filename);
	return EXIT_SUCCESS;
}

